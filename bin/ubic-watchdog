#!/usr/bin/perl

use strict;
use warnings;

=head1 NAME

ubic-watchdog - watchdog which checks all ubic services.

=head1 SYNOPSIS

    ubic-watchdog [-v]

=cut

use Getopt::Long 2.33;
use Pod::Usage;

use Yandex::Logger;
use Yandex::Lockf;
use Yandex::X qw(xfork);
use Ubic;

my $verbose;
GetOptions(
    'v|verbose' => \$verbose,
) or pod2usage(2);

if ($<) {
    die "ubic-watchdog requires root access";
}

my @services = Ubic->services;

sub check {
    my $service = shift;
    my $name = $service->full_name;
    if ($verbose) {
        INFO "Checking $name\n";
    }
    eval {
        my $lock = Ubic->lock($name);
        if ($service->isa('Ubic::Multiservice')) {
            INFO "$name is multiservice, checking subservices\n" if $verbose;
            for my $service ($service->services) {
                unless (xfork) {
                    check($service);
                    exit;
                }
            }
            1 while wait() > 0;
            return;
        }
        unless (Ubic->is_enabled($name)) {
            INFO "$name disabled\n" if $verbose;
            return;
        }
        # TODO - alarm?
        my $status = Ubic->status($name);
        unless ($status eq 'running') {
            Ubic->set_cached_status($name, $status->status); # following start can throw exception
            INFO "$name is broken, restarting";
            Ubic->start($name);
        }
        $status = $service->status;
        if ($status ne 'running') {
            INFO "$name started, but status is still '$status'";
        }
        Ubic->set_cached_status($name, $status); # if service's start implementation is invalid, ubic-watchdog will restart it every minute, so be careful
    }; if ($@) {
        ERROR "Failed to check $name: $@";
    }
    if ($verbose) {
        INFO "$name checked\n";
    }
}

for my $service (@services) {
    unless (xfork) {
        check($service);
        exit;
    }
}
1 while wait() > 0;

