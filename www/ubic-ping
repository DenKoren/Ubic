#!/usr/bin/perl
# Copyright (c) 2009 Yandex.ru

package Ubic::Ping;

use strict;
use warnings;

=head1 NAME

ubic-ping - http server which returns service status by it's name or port

=cut

use Ubic;
use Params::Validate qw(:all);

use base qw(HTTP::Server::Simple::CGI);

sub print_status($;$) {
    my ($service, $options) = validate_pos(@_, 1, { type => HASHREF, default => {} });

    unless (Ubic->is_enabled($service->full_name)) {
        if ($options->{noc}) {
            print "HTTP/1.0 500 Disabled\r\n\r\n";
        }
        else {
            print "HTTP/1.0 200 OK\r\n\r\n";
        }
        print "disabled\n";
        return;
    }
    my $status = Ubic->cached_status($service->full_name); # should read status from static file on disk
    if ($status eq 'running') {
        print "HTTP/1.0 200 OK\r\n\r\n";
        print "ok\n";
        return;
    }
    else {
        if ($options->{noc}) {
            if ($status =~ /^[\w ]+$/) {
                print "HTTP/1.0 500 $status\r\n\r\n";
            }
            else {
                # invalid status, fallback to default status message
                print "HTTP/1.0 500 Wrong status\r\n\r\n";
            }
        }
        else {
            print "HTTP/1.0 200 OK\r\n\r\n";
        }
        print "$status\n";
        return;
    }
}

sub find_by_port {
    my ($service, $port) = validate_pos(@_, 1, { regex => qr/^\d+$/ });
    for $_ ($service->services) {
        if ($_->isa('Ubic::Catalog')) {
            # multiservice
            my $found = find_by_port($_, $port);
            return $found if $found;
        }
        else {
            return $_ if $_->port == $port;
        }
    }
    return;
}

sub handle_request {
    my ($self, $cgi) = @_;

    eval {
        if ($cgi->path_info eq '/ping') {
            # ping self
            print "HTTP/1.0 200 OK\r\n\r\n";
            print "ok\n";
            return;
        }
        elsif ( $cgi->path_info =~ m{^/noc/(\d+)/?$}) {
            my $port = $1;
            my $service = find_by_port(Ubic->root_service, $port); # TODO - cache?
            unless (defined $service) {
                print "HTTP/1.0 404 Not found\r\n\r\n";
                print "Service at port '$port' not found\n";
                return;
            }
            print_status($service, { noc => 1 });
            return;
        }
        elsif ($cgi->path_info =~ m{^/status/port/(\d+)/?$}) {
            my $port = $1;
            my $service = find_by_port(Ubic->root_service, $port);
            unless (defined $service) {
                print "HTTP/1.0 404 Not found\r\n\r\n";
                print "Service at port '$port' not found\n";
                return;
            }
            print_status($service);
            return;
        }
        elsif (my ($name) = $cgi->path_info =~ m{^/status/service/(.+?)/?$}) {
            my $service = eval {
                Ubic->service($name);
            }; if ($@) {
                print "HTTP/1.0 404 Not found\r\n\r\n";
                print "Service with name '$name' not found\n";
                return;
            }
            print_status($service);
        }
        else {
            print "HTTP/1.0 404 Not found\r\n\r\n";
            print "Expected /status/name/NAME or /status/port/PORT query\n";
            return;
        }
    }; if ($@) {
        print "HTTP/1.0 500 Internal error\r\n\r\n";
        print "Error: $@";
        return;
    }
}

1;

=head1 AUTHOR

Vyacheslav Matjukhin <mmcleric@yandex-team.ru>

=cut
